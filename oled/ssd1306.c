// ssd1306.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "oled/ssd1306.h"

#define SSD1306_WIDTH  128
#define SSD1306_HEIGHT  64
#define SSD1306_I2C i2c1
#define SSD1306_I2C_ADDR 0x3C
#define SSD1306_SDA_PIN 14
#define SSD1306_SCL_PIN 15
#define SSD1306_BUF_LEN (SSD1306_WIDTH * SSD1306_HEIGHT / 8)

static uint8_t framebuffer[SSD1306_BUF_LEN]; // buffer estático (ideal para RTOS) da tela toda
static uint8_t tx_buffer[SSD1306_WIDTH + 1]; // buffer estático (idem) de uma página para ssd1306_write_data()

// Fonte 8x8 - o bit mais significativo do byte representa o pixel mais à esquerda
// e cada byte representa uma linha horizontal
// 0x20 - 0x7F (Caracteres Imprimíveis)
static const uint8_t font8x8_basic[128][8] = {
    // 0x20 - 0x7F (Caracteres Imprimíveis ASCII)
    [' '] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // Espaço
    ['!'] = {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // exclamação
    ['"'] = {0x6C,0x6C,0x48,0x00,0x00,0x00,0x00,0x00}, // aspas (aplique escape ao usar)
    ['#'] = {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // cerqiolha
    ['$'] = {0x10,0x7E,0x90,0x7C,0x12,0xFC,0x10,0x00}, // cifrão
    ['%'] = {0xC2,0xC6,0x0C,0x18,0x30,0x66,0xC6,0x00}, // porcento
    ['&'] = {0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00}, // E comercial
    ['\''] = {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00}, // apóstrofe (precisa escape aqui)
    ['('] = {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // abre parênteses
    [')'] = {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // fecha parênteses
    ['*'] = {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // multiplicação ou asterisco
    ['+'] = {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // adição ou mais
    [','] = {0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x00}, // vírgila
    ['-'] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // subtração ou menos
    ['.'] = {0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00}, // ponto
    ['/'] = {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00}, // divisão ou barra
    [':'] = {0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x00}, // dois pontos
    [';'] = {0x00,0x00,0x18,0x18,0x00,0x18,0x30,0x00}, // ´ponto e vírgula
    ['<'] = {0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x00}, // menor do que
    ['='] = {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // igral a
    ['>'] = {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00}, // maior do que
    ['?'] = {0x3C,0x66,0x0C,0x18,0x30,0x00,0x18,0x00}, // interrogação
    ['@'] = {0x3C,0x66,0x7E,0x7E,0x7E,0x42,0x3C,0x00}, // arroba
    ['['] = {0x7E,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // abre colchetes
    ['\\'] = {0xC0,0x60,0x30,0x18,0x0C,0x06,0x03,0x00}, // barra invertida (precisa escape aqui e ao usar)
    [']'] = {0x7E,0x06,0x06,0x06,0x06,0x06,0x7E,0x00}, // fecha colchetes
    ['^'] = {0x00,0x30,0x6C,0xC6,0x00,0x00,0x00,0x00}, // potenciação ou circunflexo
    ['_'] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE}, // underline ou sublinhado
    ['`'] = {0x00,0x60,0x30,0x00,0x00,0x00,0x00,0x00}, // crase
    ['{'] = {0x0C,0x18,0x18,0x60,0x18,0x18,0x0C,0x00}, // abre chaves
    ['|'] = {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // barra vertical
    ['}'] = {0x60,0x30,0x30,0x0C,0x30,0x30,0x60,0x00}, // fecha chaves
    ['~'] = {0x00,0x00,0x60,0x99,0x99,0x06,0x00,0x00}, // til (aproximadamente)
    ['0'] = {0x3C,0x66,0xCE,0xD6,0xE6,0x66,0x3C,0x00}, // 0
    ['1'] = {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00}, // 1
    ['2'] = {0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00}, // 2
    ['3'] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00}, // 3
    ['4'] = {0x0C,0x1C,0x3C,0x6C,0xFE,0x0C,0x0C,0x00}, // 4
    ['5'] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00}, // 5
    ['6'] = {0x3C,0x66,0x60,0x7C,0x66,0x66,0x3C,0x00}, // 6
    ['7'] = {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00}, // 7
    ['8'] = {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00}, // 8
    ['9'] = {0x3C,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00}, // 9
    ['A'] = {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00}, // A
    ['B'] = {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00}, // B
    ['C'] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00}, // BC
    ['D'] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00}, // CD
    ['E'] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00}, // DE
    ['F'] = {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00}, // F
    ['G'] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00}, // G
    ['H'] = {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00}, // H
    ['I'] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00}, // I
    ['J'] = {0x0E,0x06,0x06,0x06,0x66,0x66,0x3C,0x00}, // J
    ['K'] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00}, // K
    ['L'] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00}, // L
    ['M'] = {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00}, // M
    ['N'] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00}, // N
    ['O'] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // O
    ['P'] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00}, // P
    ['Q'] = {0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00}, // Q
    ['R'] = {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00}, // R
    ['S'] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00}, // S
    ['T'] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00}, // T
    ['U'] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00}, // U
    ['V'] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00}, // V
    ['W'] = {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
    ['X'] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00}, // X
    ['Y'] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00}, // Y
    ['Z'] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00}, // Z
    ['a'] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3A,0x00}, // a
    ['b'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b
    ['c'] = {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00}, // c
    ['d'] = {0x06,0x06,0x1E,0x66,0x66,0x66,0x3E,0x00}, // d
    ['e'] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e
    ['f'] = {0x1C,0x30,0x30,0x7E,0x30,0x30,0x30,0x00}, // f
    ['g'] = {0x00,0x00,0x3C,0x66,0x66,0x3E,0x06,0x7C}, // g
    ['h'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h
    ['i'] = {0x18,0x00,0x38,0x10,0x10,0x10,0x3C,0x00}, // i
    ['j'] = {0x18,0x00,0x30,0x00,0x30,0x30,0x30,0x60}, // j
    ['k'] = {0x60,0x64,0x6C,0x78,0x6C,0x66,0x62,0x00}, // k
    ['l'] = {0x38,0x10,0x10,0x10,0x10,0x10,0x7C,0x00}, // l
    ['m'] = {0x00,0x00,0xFF,0xDB,0xDB,0xDB,0xDB,0x00}, // m
    ['n'] = {0x00,0x00,0x3E,0x66,0x66,0x66,0x66,0x00}, // n
    ['o'] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o
    ['p'] = {0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,0x00}, // p
    ['q'] = {0x00,0x3C,0x66,0x66,0x7C,0x06,0x06,0x00}, // q
    ['r'] = {0x00,0x60,0x7C,0x66,0x60,0x60,0x60,0x00}, // r
    ['s'] = {0x00,0x00,0x3C,0x60,0x3C,0x06,0x7C,0x00}, // s
    ['t'] = {0x20,0x7C,0x20,0x20,0x20,0x26,0x1C,0x00}, // t
    ['u'] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u
    ['v'] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v
    ['w'] = {0x00,0x00,0x63,0x6B,0x7F,0x77,0x63,0x00}, // w
    ['x'] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x
    ['y'] = {0x00,0x00,0x66,0x66,0x3E,0x06,0x06,0x7C}, // y
    ['z'] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}, // z
};

// Envia um comando de controle ao display
static void ssd1306_write_cmd(uint8_t cmd) {
    uint8_t buf[2] = {0x80, cmd};
    i2c_write_blocking(SSD1306_I2C, SSD1306_I2C_ADDR, buf, 2, false);
}

// Envia os dados aos display. É chamada pela função ssd1306_show()
static void ssd1306_write_data(const uint8_t *data, size_t len) {
    // Verifica se o buffer estático é grande o suficiente
    if (len + 1 > sizeof(tx_buffer)) {
        return;
    }
    tx_buffer[0] = 0x40;
    memcpy(&tx_buffer[1], data, len);
    i2c_write_blocking(SSD1306_I2C, SSD1306_I2C_ADDR, tx_buffer, len + 1, false);
}

// Inicializa o display e o barramento I2C
void ssd1306_init(void) {
    i2c_init(SSD1306_I2C, 400 * 1000);
    gpio_set_function(SSD1306_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SSD1306_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SSD1306_SDA_PIN);
    gpio_pull_up(SSD1306_SCL_PIN);
    sleep_ms(100);

    const uint8_t init_cmds[] = {
        0xAE,       // Display OFF
        0x20, 0x00, // Set Memory Addressing Mode = Horizontal
        0x40,       // Set Display Start Line = 0
        0xA1,       // Set Segment Re-map (espelha horizontalmente)
        0xA8, 0x3F, // Set Multiplex Ratio = 63 (para 64 linhas)
        0xC8,       // COM Output Scan Direction remap (espelha vertical)
        0xD3, 0x00, // Set Display Offset = 0
        0xDA, 0x12, // Set COM Pins hardware configuration
        0x81, 0x7F, // Set Contrast Control = 0x7F
        0xA4,       // Resume to RAM content (normal display mode)
        0xA6,       // Set Normal Display (não invertido)
        0xD5, 0x80, // Set Display Clock Divide Ratio/Oscillator Frequency
        0x8D, 0x14, // Charge Pump = Enable
        0xDB, 0x20, // Set VCOMH Deselect Level
        0xD9, 0xF1, // Set Pre-charge Period
        0xAF        // Display ON
};


    for (uint8_t i = 0; i < sizeof(init_cmds); i++) {
        ssd1306_write_cmd(init_cmds[i]);
    }
    ssd1306_clear();
    ssd1306_show();
}

// Limpa o framebuffer (é necessário chamar ssd1306_show() para refletir no display)/ 
void ssd1306_clear(void) {
    memset(framebuffer, 0, sizeof(framebuffer));
}

// Desenha um pixel nas coordenadas (x,y) no framebuffer
void ssd1306_draw_pixel(int x, int y, bool on) {
    if (x < 0 || x >= SSD1306_WIDTH || y < 0 || y >= SSD1306_HEIGHT) return;
    int byte_index = (y / 8) * SSD1306_WIDTH + x;
    if (on)
        framebuffer[byte_index] |= (1 << (y % 8));
    else
        framebuffer[byte_index] &= ~(1 << (y % 8));
}

// Desenha um caractere 8x8 no framebuffer (é necessário chamar ssd1306_show() para refletir no display)
void ssd1306_draw_char(int x, int y, char c) {
    const uint8_t *bitmap = font8x8_basic[(unsigned char)c];
    for (int row = 0; row < 8; row++) {
        uint8_t bits = bitmap[row];
        for (int col = 0; col < 8; col++) {
            // bit mais significativo (7 - col) representa pixel mais à esquerda
            bool on = (bits & (1 << (7 - col))) != 0;
            ssd1306_draw_pixel(x + col, y + row, on);
        }
    }
}

// Desenha uma string no framebuffer (é necessário chamar ssd1306_show() para refletir no display)
void ssd1306_draw_string(int x, int y, const char *str) {
    while (*str) {
        ssd1306_draw_char(x, y, *str++);
        x += 8;
    }
}

// Envia o conteúdo atual do framebuffer para o display via I2C
void ssd1306_show(void) {
    for (uint8_t page = 0; page < SSD1306_HEIGHT / 8; page++) {
        ssd1306_write_cmd(0xB0 + page);
        ssd1306_write_cmd(0x00);
        ssd1306_write_cmd(0x10);
        ssd1306_write_data(&framebuffer[page * SSD1306_WIDTH], SSD1306_WIDTH);
    }
}

// Desenha uma linha entre dois pontos no framebuffer de (x0,y0) até (x1,y1) (necessita ssd1306_show() após)
void ssd1306_draw_line(int x0, int y0, int x1, int y1, bool on) {
    int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int err = dx + dy, e2;
    while (true) {
        ssd1306_draw_pixel(x0, y0, on);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}


// Anima um pixel caminhando horizontalmente pelo meio do display em 2 segundos
void ssd1306_walk_horizontal_pixel(void) {
    ssd1306_clear();
    int y = SSD1306_HEIGHT / 2; // linha central vertical (y = 32)
    const int delay_ms = 2000 / SSD1306_WIDTH; // ≈ 15.6ms por passo

    for (int x = 0; x < SSD1306_WIDTH; x++) {
        ssd1306_draw_pixel(x, y, true);
        ssd1306_show();
        sleep_ms(delay_ms);
    }
}